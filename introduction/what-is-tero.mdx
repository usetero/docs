---
title: "What is Tero?"
description: "A control plane for observability data"
icon: "robot"
iconType: "duotone"
---

<img src="/images/tero-hero.svg" alt="Tero" />

Most observability problems aren't platform problems. They're data problems: too much noise, not enough signal, no way to know what's worth keeping. At least 40% of what you're sending to Datadog or Splunk is waste. That's why debugging is slow, dashboards are cluttered, and costs keep growing.

Tero fixes the data.

It's a control plane for observability data. Tero connects to your existing stack, analyzes every log, metric, and trace, and tells you exactly what's wrong. Not just volume breakdowns. Specific statements you can verify:

- [Health checks](/data-quality/logs/health-checks): Kubernetes probes hitting `/health` every 10 seconds, millions of logs nobody queries
- [Logs in hot path](/data-quality/logs/logs-in-hot-path): middleware logging "Incoming request" on every HTTP request
- [High cardinality tags](/data-quality/metrics/high-cardinality-tags): `user_id` as a metric tag, exploding your custom metrics

You review the [rules](/data-quality/overview), approve what you agree with, and Tero [enforces](/data-quality/enforcement/overview). In your provider, at the edge, or in your code. It monitors for drift. Problems you fix stay fixed.

Like a control plane for your infrastructure, but for your data. Declare what clean looks like, enforce it everywhere, catch drift when it happens.
