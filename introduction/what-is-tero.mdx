---
title: "What is Tero?"
description: "A control plane for observability data"
icon: "robot"
iconType: "duotone"
---

<img src="/images/tero-hero.svg" alt="Tero" />

Most observability problems aren't platform problems. They're data problems: too much noise, not enough signal, no way to know what's worth keeping. At least 40% of what you're sending to Datadog or Splunk is waste. That's why debugging is slow, dashboards are cluttered, and costs keep growing.

Tero fixes the data.

It's a control plane for observability data. Tero connects to your existing stack, analyzes every log, metric, and trace, and tells you exactly what's wrong. Not just volume breakdowns. Specific statements you can verify:

- [Redundant attributes](/data-quality/logs/redundant-attributes): `time` and `@timestamp` contain the same value
- [Health checks](/data-quality/logs/health-checks): `/health` endpoint logging 86,400 times a day
- [Leftover debug logs](/data-quality/logs/leftover-debug-logs): `logger.debug("got here")` shipped to production

You review the [rules](/data-quality/overview), approve what you agree with, and Tero [enforces](/data-quality/enforcement/overview). In your provider, at the edge, or in your code. It monitors for drift. Problems you fix stay fixed.

Like a control plane for your infrastructure, but for your data. Declare what clean looks like, enforce it everywhere, catch drift when it happens.
