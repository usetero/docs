---
title: "Taking action on waste"
sidebarTitle: "Taking action"
description: "From insight to elimination"
icon: "bolt"
iconType: "duotone"
---

Tero shows you what's waste and why. Now you need to eliminate it.

You have three options: filter in your provider, fix in code, or drop in your infrastructure. They're not mutually exclusive. Most teams use all three, depending on what the waste is and how permanent they want the fix to be.

## In your provider

<Tabs>
  <Tab title="Datadog">
    <Frame>
      <img src="/images/how-it-works-datadog-4-in-provider.svg" alt="Tero configuring Datadog" />
    </Frame>

    Tero configures [exclusion filters](https://docs.datadoghq.com/logs/log_configuration/indexes/#exclusion-filters) to prevent waste from being indexed, and modifies [pipelines](https://docs.datadoghq.com/logs/log_configuration/pipelines/) to change how logs are parsed and routed. See [Datadog integration →](/integrations/datadog#actions)

    <Warning>
    Exclusion filters prevent indexing but not ingestion. You still pay ingestion fees. To avoid those, [filter in your infrastructure](#in-your-infrastructure).
    </Warning>
  </Tab>
  <Tab title="Splunk">
    <Frame>
      <img src="/images/how-it-works-splunk-4-in-provider.svg" alt="Tero configuring Splunk" />
    </Frame>

    Tero configures [Ingest Actions](https://docs.splunk.com/Documentation/SplunkCloud/latest/Data/DataIngest) to filter waste before indexing. See [Splunk integration →](/integrations/splunk#actions)
  </Tab>
</Tabs>

The fastest path to savings. No deploys, no code changes, no waiting for the next release cycle. Tero configures your provider directly via API. You identify waste, apply the filter, and it stops being indexed immediately. Fully reversible — if you made a mistake, undo it just as fast.

This is a good starting point. You prove value quickly, build confidence in the analysis, and see savings in your next bill. But providers have limits. Datadog caps exclusion filters per index. Splunk caps ingest action rulesets. At some point you hit a ceiling. And there's lock-in — if you switch providers, your filters don't come with you. For scale, you'll want to move filtering into your infrastructure.

## In your code

<Frame>
  <img src="/images/how-it-works-generic-4-in-code.svg" alt="Fix waste in your code" />
</Frame>

Some waste shouldn't exist at all. Debug statements that made it to production. Verbose logging someone added during an incident and forgot to remove. Instrumentation that made sense during development but serves no purpose now.

For this kind of waste, the right fix is at the source. Remove the code that produces it. No filtering, no sampling — just stop emitting it.

Tero can help you get there in a few ways.

### Pull requests

Tero opens PRs directly against your repo. It knows which service produces the waste, which repo that maps to, and what code needs to change. You review and merge.

Changes are batched by [category](/questions/waste/how-it-works#categories). You're not getting one PR per log event — that would be noise. Instead, Tero groups related fixes: all the debug output in a service, all the leftover instrumentation from a specific feature. PRs route to owning teams based on your [service catalog](/context/services), so the right people review the right changes.

[Connect GitHub](/integrations/github) to enable pull requests.

### Tickets

Some teams prefer to schedule work themselves rather than receive PRs. Tero can create issues in Jira, Linear, or GitHub instead. Same information — what the waste is, why it matters, what to change — but the team decides when to address it.

This works well when you want visibility into waste without forcing immediate action. Teams see the cost, prioritize against other work, and fix when ready.

[Connect GitHub](/integrations/github) to enable issues.

### CLI

```bash
tero fix
```

Sometimes you want to make the change yourself. The CLI shows you Tero's recommendations interactively. You see what it suggests, understand the reasoning, and apply what makes sense. Useful when you're already in the code and want to clean things up as you go.

### MCP

Tero works as an MCP server. If you're using an AI assistant for development, it sees Tero's recommendations in context. Debug output gets flagged before it ships. Excessive logging gets caught during code review. The waste never makes it to production in the first place.

## In your infrastructure

<Tabs>
  <Tab title="Datadog">
    <Frame>
      <img src="/images/how-it-works-datadog-4-in-infrastructure.svg" alt="Tero in your infrastructure" />
    </Frame>
  </Tab>
  <Tab title="Splunk">
    <Frame>
      <img src="/images/how-it-works-splunk-4-in-infrastructure.svg" alt="Tero in your infrastructure" />
    </Frame>
  </Tab>
  <Tab title="OpenTelemetry">
    <Frame>
      <img src="/images/how-it-works-otel-4-in-infrastructure.svg" alt="Tero in your infrastructure" />
    </Frame>
  </Tab>
</Tabs>

This is where you scale without limits. Instead of configuring your provider, you run Tero's policy engine in your own infrastructure. [Policies](/edge/policy-reference/log-filter) execute before data leaves your network. Drop, sample, trim — whatever you need, applied at the source.

Policies are atomic rules. Each one does one thing: drop this event, sample that one, trim this attribute. Why atomic? Because monolithic pipeline configurations break down at scale. Policies are composable, auditable, and designed for thousands of rules. No limits.

You choose where to run them. [Tero Edge](/edge/overview) is purpose-built for policy execution — a lightweight proxy that fits at the host, in your pipeline, or in serverless environments. Or use our drop-in replacements for the Datadog Agent, OTel Collector, Vector, or Fluent Bit. Same config you already have, new capabilities.

The policies are yours. They're portable. If you switch providers tomorrow, your filtering logic comes with you.

### Sync to git

Policies can sync to a git repository. You push to a folder, open pull requests, merge to main. Version control, audit history, review before apply.

This matters when you have multiple teams, compliance requirements, or just want to know who changed what and when. Policies become code, managed like code.

## Let categories guide you

You don't have to decide manually every time. Categories map to where fixes typically belong.

| Category | Where it usually lives |
|----------|----------------------|
| Malformed data, stray debugging | Code — shouldn't exist |
| Health checks | Infrastructure — filter |
| Repetitive events | Infrastructure — sample |
| Redundant fields, static fields | Infrastructure — trim |

Malformed data and stray debugging are code problems. The fix is to stop emitting them. Health checks and repetitive events are fine to emit — you just don't need to store all of them. Filter or sample in your infrastructure.

You can configure Tero to route automatically. Malformed data and stray debugging open PRs. Health checks and repetitive events push policies. You review what needs judgment, the obvious stuff flows without intervention.

## Push to teams

At some point, you don't want to be the person approving every change.

And you can't just remove other engineers' data without asking. That log you think is waste? Maybe they added it after an incident and it's saved them twice since. You don't have that context. They do.

Push ownership to service teams. Tero's team views show each team their services, their waste, their costs. Engineers approve changes to their own services. They see the impact, understand the trade-offs, make the call.

The conversation shifts. It's not "platform says drop this" — it's "here's what your service costs, you decide." Teams own their data quality the same way they own their uptime.

## Set quality SLOs

Now that you can quantify waste, you can set standards.

Before Tero, waste was vague. You knew it existed but couldn't measure it. Now you have numbers: percentage of waste per service, cost per team, trends over time.

That makes it manageable. Set targets per service, per team, org-wide. Waste becomes a metric like any other — something teams own and improve. Not a quarterly panic before renewal. A continuous quality standard.
