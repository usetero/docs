---
title: "High cardinality tags"
description: "Metric tags with unbounded values that explode storage"
icon: "chart-scatter"
iconType: "duotone"
---

Metric tags with unbounded or highly variable values. User IDs, request IDs, timestamps, IP addresses as tags. Each unique value creates a new time series, and your metric storage explodes.

## Why it happens

A developer adds a tag to help with debugging. `user_id` on a latency metric seems useful—you could see latency per user. But you have a million users. Now you have a million time series for one metric.

Metrics are meant to be aggregated. Tags with high cardinality defeat the purpose. You end up with millions of sparse time series that nobody queries and cost a fortune to store.

## Example

<Tabs>
  <Tab title="Before">
    A request latency metric with `user_id` as a tag:
    ```
    http_request_duration_seconds{service="api", endpoint="/users", user_id="usr_abc123"} 0.045
    http_request_duration_seconds{service="api", endpoint="/users", user_id="usr_def456"} 0.052
    http_request_duration_seconds{service="api", endpoint="/users", user_id="usr_ghi789"} 0.038
    ```
    One metric × one endpoint × one million users = one million time series.
  </Tab>
  <Tab title="After">
    ```
    http_request_duration_seconds{service="api", endpoint="/users"} 0.045
    ```
    Tag removed. Aggregate the metric, use logs for per-user debugging.
  </Tab>
</Tabs>

Tero generates a policy to remove the high-cardinality tag:

```yaml
id: remove-user-id-tag
name: Remove user_id tag from metrics
description: Drop high-cardinality user_id tag. Creates millions of sparse time series.
metric:
  match:
    - tag: user_id
      exists: true
  transform:
    remove_tags:
      - user_id
```

<Tip>
  High cardinality is usually consistent across metrics. If `user_id` is a problem on one metric, it's a problem everywhere. Apply these policies globally.
</Tip>

## Common high-cardinality tags

These tags frequently cause cardinality explosions:

- **Identifiers**: `user_id`, `request_id`, `session_id`, `trace_id`, `order_id`
- **Network**: `ip_address`, `client_ip`, `source_ip`
- **Time-based**: `timestamp`, `date`, `minute`
- **Content**: `url` (with query params), `user_agent`, `error_message`

The test: could this tag have thousands or millions of unique values? If yes, it probably shouldn't be a metric tag.

## Recommended enforcement

<CardGroup cols={2}>
  <Card title="Enforce at edge" icon="server" href="/policies/enforcement/edge">
    Strip the tag before metrics reach your provider.
  </Card>
  <Card title="Open PRs" icon="code-pull-request" href="/policies/enforcement/open-prs">
    Remove the tag from instrumentation code.
  </Card>
</CardGroup>

The best fix is removing the tag from instrumentation. If that's not possible quickly, strip it at the edge to stop the bleeding while you fix the code.

## How it works

Tero analyzes tag cardinality across your metrics. Tags with thousands or more unique values are flagged as high cardinality.

Tero also checks whether these tags are used in queries or dashboards. A tag with 100,000 unique values that nobody filters by is a clear candidate for removal. A tag that appears in dashboards might be intentional (though probably still a mistake).
